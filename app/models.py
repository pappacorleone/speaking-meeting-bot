"""Data models for the Speaking Meeting Bot API."""

from enum import Enum
from typing import Any, Dict, List, Optional
from datetime import datetime

from pydantic import BaseModel, Field, HttpUrl


# =============================================================================
# Diadi Session Enums
# =============================================================================


class SessionStatus(str, Enum):
    """Status of a Diadi facilitation session."""

    DRAFT = "draft"
    PENDING_CONSENT = "pending_consent"
    READY = "ready"
    IN_PROGRESS = "in_progress"
    PAUSED = "paused"
    ENDED = "ended"
    ARCHIVED = "archived"


class Platform(str, Enum):
    """Meeting platform for the session."""

    ZOOM = "zoom"
    MEET = "meet"
    TEAMS = "teams"
    DIADI = "diadi"  # Future: native video


class FacilitatorPersona(str, Enum):
    """Available AI facilitator personas."""

    NEUTRAL_MEDIATOR = "neutral_mediator"
    DEEP_EMPATH = "deep_empath"
    DECISION_CATALYST = "decision_catalyst"


# =============================================================================
# Diadi Session Models
# =============================================================================


class Participant(BaseModel):
    """A participant in a Diadi session."""

    id: str
    name: str
    role: str  # "creator" | "invitee"
    consented: bool = False


class FacilitatorConfig(BaseModel):
    """Configuration for the AI facilitator."""

    persona: FacilitatorPersona = FacilitatorPersona.NEUTRAL_MEDIATOR
    interrupt_authority: bool = True
    direct_inquiry: bool = True
    silence_detection: bool = False


class Session(BaseModel):
    """A Diadi facilitation session."""

    id: str
    title: Optional[str] = None
    goal: str = Field(..., max_length=200)
    relationship_context: str
    platform: Platform
    meeting_url: Optional[str] = None
    duration_minutes: int = 30
    scheduled_at: Optional[str] = None
    status: SessionStatus = SessionStatus.DRAFT
    participants: List[Participant] = []
    facilitator: FacilitatorConfig
    created_at: str
    invite_token: str
    bot_id: Optional[str] = None
    client_id: Optional[str] = None


class TalkBalanceMetrics(BaseModel):
    """Metrics for talk balance between participants."""

    participant_a: Dict[str, Any]  # {id, name, percentage}
    participant_b: Dict[str, Any]
    status: str  # "balanced" | "mild_imbalance" | "severe_imbalance"


class InterventionRecord(BaseModel):
    """Record of an AI intervention during a session."""

    id: str
    type: str
    modality: str
    message: str
    target_participant: Optional[str] = None
    created_at: str


class SessionSummary(BaseModel):
    """Post-session summary generated by AI."""

    session_id: str
    duration_minutes: int
    consensus_summary: str
    action_items: List[str]
    balance: TalkBalanceMetrics
    intervention_count: int
    key_agreements: List[Dict[str, str]] = []


# =============================================================================
# Diadi Session Request/Response Models
# =============================================================================


class CreateSessionRequest(BaseModel):
    """Request model for creating a new Diadi session."""

    goal: str = Field(..., max_length=200)
    relationship_context: str
    facilitator: FacilitatorConfig = Field(default_factory=FacilitatorConfig)
    duration_minutes: int = 30
    scheduled_at: Optional[str] = None
    platform: Platform = Platform.MEET
    partner_name: str


class CreateSessionResponse(BaseModel):
    """Response model for session creation."""

    session_id: str
    status: SessionStatus
    invite_link: str
    invite_token: str


class ConsentRequest(BaseModel):
    """Request model for partner consent."""

    invite_token: str
    invitee_name: str
    consented: bool


class ConsentResponse(BaseModel):
    """Response model for consent action."""

    status: SessionStatus
    participants: List[Participant]


class StartSessionRequest(BaseModel):
    """Request model for starting a session."""

    meeting_url: str


class StartSessionResponse(BaseModel):
    """Response model for session start."""

    status: SessionStatus
    bot_id: str
    client_id: str
    event_url: str


class SessionEventPayload(BaseModel):
    """Payload for WebSocket session events."""

    type: str  # "balance_update" | "intervention" | "session_state" | etc.
    data: Dict[str, Any]
    timestamp: str = Field(default_factory=lambda: datetime.utcnow().isoformat())


# =============================================================================
# Existing Bot Models
# =============================================================================


class BotRequest(BaseModel):
    """Request model for creating a speaking bot in a meeting."""

    # Define ONLY the fields we want in our API
    meeting_url: str = Field(
        ...,
        description="URL of the Google Meet, Zoom or Microsoft Teams meeting to join",
    )
    bot_name: str = Field("", description="Name to display for the bot in the meeting")
    personas: Optional[List[str]] = Field(
        None,
        description="List of persona names to use. The first available will be selected.",
    )
    bot_image: Optional[str] = None
    entry_message: Optional[str] = None
    extra: Optional[Dict[str, Any]] = None
    enable_tools: bool = True
    prompt: Optional[str] = None

    # NOTE: streaming_audio_frequency is intentionally excluded and handled internally

    class Config:
        json_schema_extra = {
            "example": {
                "meeting_url": "https://meet.google.com/abc-defg-hij",
                "bot_name": "Meeting Assistant",
                "personas": ["helpful_assistant", "meeting_facilitator"],
                "bot_image": "https://example.com/bot-avatar.png",
                "entry_message": "Hello! I'm here to assist with the meeting.",
                "enable_tools": True,
                "extra": {"company": "ACME Corp", "meeting_purpose": "Weekly sync"},
                "prompt": "You are Meeting Assistant, a concise and professional \
                AI bot that helps summarize key points and keep the meeting on track. Speak clearly and stay on topic.",
            }
        }


class JoinResponse(BaseModel):
    """Response model for a bot joining a meeting"""

    bot_id: str = Field(
        ...,
        description="The MeetingBaas bot ID used for API operations with MeetingBaas",
    )


class LeaveResponse(BaseModel):
    """Response model for a bot leaving a meeting"""

    ok: bool


class LeaveBotRequest(BaseModel):
    """Request model for making a bot leave a meeting"""

    bot_id: Optional[str] = Field(
        None,
        description="The MeetingBaas bot ID to remove from the meeting. This will also close the WebSocket connection made through Pipecat by this bot.",
    )


class PersonaImageRequest(BaseModel):
    """Request model for generating persona images."""

    name: str = Field(..., description="Name of the persona")
    description: str = Field(None, description="Description of the persona")
    gender: Optional[str] = Field(None, description="Gender of the persona")
    characteristics: Optional[List[str]] = Field(
        None, description="List of characteristics like blue eyes, etc."
    )


class PersonaImageResponse(BaseModel):
    """Response model for generated persona images."""

    name: str = Field(..., description="Name of the persona")
    image_url: str = Field(..., description="URL of the generated image")
    generated_at: datetime = Field(..., description="Timestamp of generation")

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
